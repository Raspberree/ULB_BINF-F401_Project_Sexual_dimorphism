---
title: "BINF-F401 - Quantifying human sexual dimorphism with the dimorphism index"
author: 
  - Youmna Ayadi
  - Kevin Straatman
date: today 
format:
  html:
    code-fold: true
    toc: true
    toc-location: left
    theme: lumen
    number-sections: true
    embed-resources: true
    df-print: kable
execute:
  cache: true
  warning: false
project:
  execute-dir: project
editor: 
  markdown: 
    wrap: 80
---

```{r}
#| include: false
library(tidyverse)
library(magrittr)
library(gt)
library(ggrepel)
library(patchwork)
library(DESeq2) # BiocManager::install("DESeq2")
library(pheatmap)
library(scales)
library(GGally) # install.packages("GGally")
library(viridis)
library(VennDiagram)
library(corrplot)
library(fgsea)

#library(clusterProfiler) #BiocManager::install("clusterProfiler")

options(knitr.kable.NA = '', digits = 3) # For table formating

flog.threshold(ERROR) # To not have *.log files created when plotting venn diagrams

```


```{css}
#| echo: false
p {
  text-align: justify
}
```

```{r}
#| include: false
# customizations
theme_set(theme_light())

default_col <-  hue_pal()(4)[4]
```

```{r}
# Custom functions
# Function to reactome pathway names
process_strings <- function(x) {
  x <- gsub("_", " ", x)          # Replace underscores with spaces
  #x <- tolower(x)                 # Convert to lower case
  x <- sub("^\\S+\\s+", "", x)    # Remove the first word
  return(x)
}

# Customized volcano plot
volcano_plot <- function(data, title){
  alpha <- 0.05
  
  data <- data |> 
    as.data.frame() |> 
    rownames_to_column("gene_id")
    
  
  data <- data |> filter(!is.na(pvalue))
  
  data <- data |> 
    arrange(padj) |>
    mutate(rank = row_number()) 
  
  # all genes are set to non-significant by default
  data$category <- "NS"
  
  # Significant genes + up/down-regulated
  data$category[data$padj < alpha & data$log2FoldChange < 0] <- "Down"
  data$category[data$padj < alpha & data$log2FoldChange > 0] <- "Up"
  
  data$category <- factor(data$category)
  
  counts <- c(
    "Down" = sum(data$category == "Down"),
    "NS" = sum(data$category == "NS"),
    "Up" = sum(data$category == "Up")) |> 
    as.character()
  
  # Plot colors
  plot_cols <- c("Down" =  hue_pal()(2)[1],
                 "NS" = "grey",
                 "Up" =  hue_pal()(2)[2])
  
  # Creating the volcano plot
  plot <- data |> ggplot(aes(x = log2FoldChange, y = -log10(pvalue), color = category)) +
    geom_point(alpha = 0.7) +
    geom_vline(xintercept = c(-1, 0, 1), col = "gray", linetype = "dashed") +
    # Name added to the plot for the 20 genes with lowest adjusted p-values
    ggrepel::geom_text_repel(
      data = data |> filter(rank <= 20, padj < rank),
      aes(label = gene_id),
      size = 3,
      show.legend = FALSE,
      max.overlaps = getOption("ggrepel.max.overlaps", default = 30)) + 
    scale_color_manual(values = plot_cols, labels = counts, name = "") +
    labs(title = title,
         x = expression("log"[2]*"Fold Change"),  
         y = expression("-log"[10]*"(p-value)")) +
    
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "grey") +
    theme_light() +
    theme(legend.position = "bottom")
    
    
    return(plot)
}


# Plot of the GSEA results (Significantly up- or down-regulated pathways)
gsea_res_plots <- function(fgsea_results, alpha = 0.05){
  topPathwaysUp <- fgsea_results |> filter(ES > 0 & padj < alpha)
  topPathwaysDown <- fgsea_results |> filter(ES < 0 & padj < alpha)

# Plots of the results
  plot_up <- topPathwaysUp |> 
    mutate(pathway = pathway |> process_strings() |>  str_wrap(width = 40) ) |> 
    ggplot(aes(reorder(pathway, NES), NES)) +
      geom_col(fill = hue_pal()(2)[2]) +
      coord_flip() +
      labs(x="Pathway", y="Normalized Enrichment Score",
           title="Top upregulated Reactome pathways") 
  
  plot_down <- topPathwaysDown |> 
    mutate(pathway = pathway |> process_strings() |>  str_wrap(width = 40) ) |> 
    ggplot(aes(reorder(pathway, NES), NES)) +
      geom_col(fill = hue_pal()(2)[1]) +
      coord_flip() +
      labs(x="Pathway", y="Normalized Enrichment Score",
           title="Top upregulated Reactome pathways") 

  return (plot_up + plot_down)

}


```


# Importing and pre-processing the data

```{r}
RNA_counts_adjusted <- read.csv("data/RNA_counts_adjusted.csv", 
                                header = TRUE, row.names = 1)

covariates_original <- read.csv("data/covariates.csv", header = TRUE)
```


```{r}
head(RNA_counts_adjusted)

dim(RNA_counts_adjusted)

head(covariates_original)

str(covariates_original)
```


There are 12 samples with missing value of the hardy scale. What to do with it?
```{r}
is.na(covariates_original) |> sum()
is.na(covariates_original$HARDY_SCALE) |> sum()

```

There are counts for `r nrow(RNA_counts_adjusted)` genes measured in `r ncol(RNA_counts_adjusted)` samples.


We start by creating a copy of the `covariates` data frame that we can modify:
```{r}
covariates <- covariates_original
```

Replace the "." in column of so `RNA_counts_adjusted` so that they match the `SUBJID`from `covariates`.
```{r}
colnames(RNA_counts_adjusted) <- gsub(".", "-", colnames(RNA_counts_adjusted), fixed = TRUE)
```


Replace SEX column by "M" for male, and "F" for female
```{r}
covariates$SEX[covariates$SEX == "1"] <- "M"
covariates$SEX[covariates$SEX == "2"] <- "F"
```

Replace the blank PATHOLOGY_CATEGORIES by something more explicit:
```{r}
covariates$PATHOLOGY_CATEGORIES[covariates$PATHOLOGY_CATEGORIES == ""] <- "unspecified"
```


AGE_DECADE: replace by a number instead? --> ex: 60-69 -> we should probably replace by 65 (if we assume that the age in that range is normally distributed)
```{r}
age_continuous <- substr(covariates$AGE_DECADE, start = 1, stop = 1) |> paste0("5") |> as.numeric()

covariates <- covariates |> 
  mutate(AGE_CONTINUOUS = age_continuous)
```


Replace the correct variables by factors:
```{r}
covariates <- covariates |> 
  mutate(SEX = factor(SEX),
         HARDY_SCALE = factor(HARDY_SCALE),
         PATHOLOGY_CATEGORIES = factor(PATHOLOGY_CATEGORIES)
         )

covariates |>  str()

```


# Q1: Descriptive analysis of the clinical and technical variables, and of the dimoprphism indices

*Distribution*:
- Histograms of the variables

```{r}
colnames(covariates)
```


```{r}
#| label: fig-covariates_distribution
#| fig-cap: distribution of the covariates


plot_sex <- ggplot(covariates, aes(x = SEX,fill = SEX)) +
  geom_bar() +
  xlab("Sex")

plot_age_decade <- ggplot(covariates, aes(x = AGE_DECADE, fill = SEX)) +
  geom_bar(position = "dodge") +
  xlab("Age decade")

plot_hardy_scale <- ggplot(covariates, aes(x = HARDY_SCALE, fill = SEX)) +
  geom_bar(position = "dodge") +
  xlab("Hardy scale")

plot_rni <- ggplot(covariates, aes(x = RNA_INTEGRITY_NUMBER, fill = SEX)) +
  geom_histogram(bins = 20, position = "dodge") +
  xlab("RNA Integrity Number")

plot_ischemic_time <- ggplot(covariates, aes(x = ISCHEMIC_TIME, fill = SEX)) +
  geom_histogram(bins = 30, position = "dodge") +
  xlab("Ischemic time")

plot_pathology_categories <- ggplot(covariates, aes(x = PATHOLOGY_CATEGORIES, fill = SEX)) +
  geom_bar(position = "dodge") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 10)) +
  xlab("Pathology categories")

plot_histo_di <- ggplot(covariates, aes(x = HISTO_DI, fill = SEX)) +
  geom_histogram(position = "dodge", bins = 30) +
  xlab("Dimorphism indices from histology profiles")

plot_rna_di <- ggplot(covariates, aes(x = RNA_DI, fill = SEX)) +
  geom_histogram(bins = 30, position = "dodge") +
  xlab("Dimorphism indices from RNA-seq transcriptomes")


(plot_sex + plot_age_decade + plot_hardy_scale) / 
  (plot_rni + plot_ischemic_time) +
  (free(plot_pathology_categories) + (plot_histo_di / plot_rna_di)) +
  plot_annotation(tag_levels = "a") +
  plot_layout(guides = "collect")
  
```


*Correlation*:
- Correlation of the variables with one another: for correlation between two categorical variables, the Chi-square test of independence is commonly used
- For continuous variables: pairs plot + calculate Pearson correlation.
- ANOVA for link between categorical and continuous variables??


```{r}
#| warning: false

covariates |>
  select(AGE_CONTINUOUS, RNA_INTEGRITY_NUMBER, ISCHEMIC_TIME, HISTO_DI, RNA_DI) |> 
  ggpairs(aes(col = covariates$SEX, alpha = 0.5), progress = FALSE)

```


*Confounding variables (confounding for dimorphism indices and clinical variables)*:
- Look at RNA integrity and ischemic time
- do a PCA on the counts and color the points by a technical factor: see if we observe a gradient. 
[example for detecting batch effect](https://evayiwenwang.github.io/Managing_batch_effects/detect.html)


To estimate the size factors and the vst (variance stabilizing transformation) with DESeq2: every gene contains at least one zero, cannot compute log geometric means. Solution: add a pseudo-count of 1 to every entry:

```{r}
mt <- match(colnames(RNA_counts_adjusted), covariates$SUBJID)

RNA_counts_ds <- DESeqDataSetFromMatrix(
  countData = RNA_counts_adjusted + 1,
  colData = covariates[mt, ],
  design = ~ 1 # no design yet, as we have to determine the confounding factors
)
```




```{r}
vst_counts <- vst(RNA_counts_ds)

plotPCA(vst_counts, intgroup = c("SEX"), ntop = 500) +
  coord_fixed() +
  aes(alpha = 0.8) +
  scale_color_discrete(name = "Sex")


plotPCA(vst_counts, intgroup = c("SEX"), ntop = 200) +
  coord_fixed() +
  geom_point(alpha = 0.5) +
  scale_color_discrete(name = "Sex")

```

```{r}
#| label: fig-PCA_rnadi
#| fig-cap: PCA individuals map of the samples colored by their dimorphism index. (a) Male samples (b) Female samples.

PCA_rnadi_M <- vst_counts[,colData(vst_counts)$SEX == "M"] |> 
  plotPCA(intgroup = c("RNA_DI"), ntop = 500) +
  scale_color_continuous(type = "viridis", name = "RNA DI") +
  coord_fixed() +
  ggtitle("Males")

PCA_rnadi_F <- vst_counts[,colData(vst_counts)$SEX == "F"] |> 
  plotPCA(intgroup = c("RNA_DI"), ntop = 500) +
  scale_color_continuous(type = "viridis", name = "RNA DI") +
  coord_fixed() +
  ggtitle("Females")

PCA_rnadi_M + PCA_rnadi_F + plot_annotation(tag_levels = "a") + 
  plot_layout(guides = "collect")  & theme(legend.position = 'bottom')

```

```{r}
#| label: fig-PCA_histodi
#| fig-cap: PCA individuals map of the samples colored by their histological dimorphism index. (a) Male samples (b) Female samples.

PCA_histodi_M <- vst_counts[,colData(vst_counts)$SEX == "M"] |> 
  plotPCA(intgroup = c("HISTO_DI"), ntop = 500) +
  scale_color_continuous(type = "viridis", name = "HISTO DI") +
  coord_fixed() +
  ggtitle("Males")

PCA_histodi_F <- vst_counts[,colData(vst_counts)$SEX == "F"] |> 
  plotPCA(intgroup = c("HISTO_DI"), ntop = 500) +
  scale_color_continuous(type = "viridis", name = "HISTO DI") +
  coord_fixed() +
  ggtitle("Females")

PCA_histodi_M + PCA_histodi_F + plot_annotation(tag_levels = "a") + 
  plot_layout(guides = "collect")  & theme(legend.position = 'bottom')

```



```{r}
plotPCA(vst_counts, intgroup = c("AGE_CONTINUOUS"), ntop = 500) +
  scale_color_continuous(type = "viridis", name = "Age (continuous)") +
  coord_fixed()

PCA_age_M <- plotPCA(vst_counts[,colData(vst_counts)$SEX == "M"], intgroup = c("AGE_CONTINUOUS"), ntop = 500, pcsToUse = 1:2) +
  scale_color_continuous(type = "viridis", name = "Age (continuous)") +
  coord_fixed() +
  ggtitle("Males")

PCA_age_F <- plotPCA(vst_counts[,colData(vst_counts)$SEX == "F"], intgroup = c("AGE_CONTINUOUS"), ntop = 500, pcsToUse = 1:2) +
  scale_color_continuous(type = "viridis", name = "Age (continuous)") +
  coord_fixed() +
  ggtitle("Females")

PCA_age_M + PCA_age_F + plot_annotation(tag_levels = "a") + 
  plot_layout(guides = "collect") & theme(legend.position = 'bottom')

```
Women of age below 40 seem to cluster more to the right of the plot --> possible confounding factor.

```{r}
plotPCA(vst_counts, intgroup = c("RNA_INTEGRITY_NUMBER"), ntop = 500) +
  scale_color_continuous(type = "viridis", name = "RNA integrity number") +
  coord_fixed()

 plotPCA(vst_counts[,colData(vst_counts)$SEX == "M"], intgroup = c("RNA_INTEGRITY_NUMBER"), ntop = 500, pcsToUse = 1:2) +
  scale_color_continuous(type = "viridis", name = "RIN") +
  coord_fixed()
 
 
  plotPCA(vst_counts[,colData(vst_counts)$SEX == "F"], intgroup = c("RNA_INTEGRITY_NUMBER"), ntop = 500, pcsToUse = 1:2) +
  scale_color_continuous(type = "viridis", name = "RIN") +
  coord_fixed()
```


If we take a lot of top genes (selected by row variance) into account for the PCA, the samples seem to form clusters based on the Hardy scale value.
```{r}
plotPCA(vst_counts, intgroup = c("HARDY_SCALE"), ntop = 10000) +
  coord_fixed() +
  aes(alpha = 0.5) +
  scale_color_discrete(name = "Hardy scale")
```


```{r}
plotPCA(vst_counts[,colData(vst_counts)$PATHOLOGY_CATEGORIES != "unspecified"], intgroup = c("PATHOLOGY_CATEGORIES"), ntop = 500, pcsToUse = 1:2) +
  coord_fixed() +
  aes(alpha = 0.8) +
  scale_color_discrete(name = "Pathology categories") +
  ggtitle("PCA - individuals' map with samples colored by pathology category", subtitle = "Unspecified pathology categories are removed")


plotPCA(vst_counts, intgroup = c("PATHOLOGY_CATEGORIES"), ntop = 500, pcsToUse = 1:2) +
  coord_fixed() +
  aes(alpha = 0.8) +
  scale_color_discrete(name = "Pathology categories")
```



```{r}
library("cowplot")

pcaData <- plotPCA(vst_counts, intgroup = c("HARDY_SCALE"), ntop = 10000, returnData = TRUE)

percentVar <- round(100 * attr(pcaData, "percentVar"))



# Create the PCA plot
p <- ggplot(pcaData, aes(PC1, PC2, color = HARDY_SCALE)) + 
  geom_point(size = 3, alpha = 0.5) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  theme_minimal()

# Create density plots for the x and y axes
xdens <- axis_canvas(p, axis = "x") +
  geom_histogram(data = pcaData, aes(x = PC1, fill = HARDY_SCALE), alpha = 0.7, position = "identity")

ydens <- axis_canvas(p, axis = "y", coord_flip = TRUE) +
  geom_histogram(data = pcaData, aes(x = PC2, fill = HARDY_SCALE), alpha = 0.7, position = "identity") +
  coord_flip()

# Combine the PCA plot with the density plots
p_combined <- insert_xaxis_grob(p, xdens, grid::unit(1, "in"), position = "top") %>%
  insert_yaxis_grob(ydens, grid::unit(1, "in"), position = "right") %>%
  ggdraw()

# Display the combined plot
print(p_combined)



```

```{r}
#| label: fig-pca_plot_with_hisograms_females_age
#| fig-cap: Individual's plot of the PCA performed on the female samples only. The samples are colored by their age at death (in decades).

pcaData <- plotPCA(vst_counts[,colData(vst_counts)$SEX == "F"], intgroup = c("AGE_DECADE"), ntop = 500, returnData = TRUE)

percentVar <- round(100 * attr(pcaData, "percentVar"))

# Create the PCA plot
p <- ggplot(pcaData, aes(PC1, PC2, color = AGE_DECADE)) + 
  geom_point(size = 3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  theme_minimal()

# Create density plots for the x and y axes
xdens <- axis_canvas(p, axis = "x") +
  geom_density(data = pcaData, aes(x = PC1, fill = AGE_DECADE), alpha = 0.5)

ydens <- axis_canvas(p, axis = "y", coord_flip = TRUE) +
  geom_density(data = pcaData, aes(x = PC2, fill = AGE_DECADE), alpha = 0.5) +
  coord_flip()

# Combine the PCA plot with the density plots
p_combined <- insert_xaxis_grob(p, xdens, grid::unit(1, "in"), position = "top") %>%
  insert_yaxis_grob(ydens, grid::unit(1, "in"), position = "right") %>%
  ggdraw()

# Display the combined plot
print(p_combined)
```

**Conclusion**: technical variables that will be taken into account: `SEX, RNA_DI, AGE_CONTINUOUS, HARDY_SCALE`.
Contrasts that were are most interested in: "SEX_M_vs_"F (differentially expressed genes in males vs. females), "SEXF.RNA_DI" (to identify the genes associated with the female dimorphism index), and "SEXM.RNA_DI" (to find the genes associated with the male dimorphism index). In `DESeq2`, this corresponds to the design: `~ HARDY_SCALE + AGE_CONTINUOUS + SEX + SEX:RNA_DI ` (see next section). 

# Q2: the scale of DI-associated gene expression

## Filtering the counts
- Filter the genes with counts (too low and) too low variance:

Wikipedia: "In statistics, the median absolute deviation (MAD) is a robust measure of the variability of a univariate sample of quantitative data."
"For a univariate data set $X_1, X_2, ..., X_n$, the MAD is defined as the median of the absolute deviations from the data's median $\tilde{X} = \text{median}(X)$:

$$\text{MAD} = \text{median}(|X_i - \tilde{X}|)$$

We will only keep the 50% most variant genes (50% of genes with the highest median absolute deviation):

```{r Filtering the counts}
filtered_counts <- RNA_counts_adjusted |>
  rownames_to_column("gene") |> 
  as_tibble() |> 
  rowwise() |> 
  mutate(mad= c_across(2:ncol(RNA_counts_adjusted)) |> mad()) |> 
  ungroup() |> 
  slice_max(n = round(nrow(RNA_counts_adjusted) / 2), order_by = mad) |> 
  select(- mad) |> 
  as.data.frame() |> 
  column_to_rownames("gene")
```

The variables in the design formula cannot contain missing values (NAs). However, the HARDY_SCALE variable does contain missing values:
```{r}
cat("Missing HARDY_SCALE values:", is.na(covariates$HARDY_SCALE) |> sum())
```
For simplicity, and since the number of samples with missing values is relatively small compared to the total number of samples (`r nrow(covariates)` samples; The missing values thus represent `r (sum(is.na(covariates$HARDY_SCALE)) / nrow(covariates) |> round(3)) * 100`%), we will simply discard the samples with a missing `HARDY_SCALE` value. Other, more sophisticated methods could have been used, such as replacing the missing values by the most common one (`HARDY_SCALE` = 0 with our data set), or creating a classifier model to predict the missing values using the other covariates (source?). We could also have replaced the "NA" value by a new category called "unknown". However, since there are only 12 samples in that category, and there quite a lot of variables in the design, we would risk having a low statistical power (very few degrees of freedom).

```{r}
non_na_samples <- !is.na(covariates$HARDY_SCALE)

non_na_covariates <- covariates[non_na_samples,]

filtered_counts <- filtered_counts[, non_na_samples]

```


## Differential gene expression analysis
```{r}
alpha <- 0.05
```


As recommended by `DESeq2`, we will center and scale the continuous variables (`AGE_CONTINUOUS`, and `RNA_DI`) to improve GLM convergence.

```{r}
non_na_covariates$AGE_CONTINUOUS <- scale(non_na_covariates$AGE_CONTINUOUS, center = TRUE, scale = TRUE)

non_na_covariates$RNA_DI <- scale(non_na_covariates$RNA_DI, center = TRUE, scale = TRUE)
```


Creating the DESeq2 object with the filtered counts:
```{r}

mt <- match(colnames(filtered_counts), non_na_covariates$SUBJID)

filtered_counts_ds <- DESeqDataSetFromMatrix(
  countData = filtered_counts,
  colData = non_na_covariates[mt, ],
  design = ~ HARDY_SCALE + AGE_CONTINUOUS + SEX + SEX:RNA_DI # Design decided in Q1
)

```


```{r running DESeq function}
filtered_counts_ds <- DESeq(filtered_counts_ds)

resultsNames(filtered_counts_ds)
```
### Genes associated with the female and male dimorphism indices


```{r}
# Genes associated with the female dimorphism index

rna_di_F_res <- results(filtered_counts_ds, name = "SEXF.RNA_DI", alpha = alpha)

NotSig_F <- sum(rna_di_F_res$padj >= alpha, na.rm = TRUE)
Down_F <- sum(rna_di_F_res$padj <= alpha & rna_di_F_res$log2FoldChange < 0, na.rm = TRUE)
Up_F <- sum(rna_di_F_res$padj <= alpha & rna_di_F_res$log2FoldChange >= 0, na.rm = TRUE)

```

```{r}
# Genes associated with the male dimorphism index

rna_di_M_res <- results(filtered_counts_ds, name = "SEXM.RNA_DI", alpha = alpha)

NotSig_M <- sum(rna_di_M_res$padj >= alpha, na.rm = TRUE)
Down_M <- sum(rna_di_M_res$padj <= alpha & rna_di_M_res$log2FoldChange < 0, na.rm = TRUE)
Up_M <- sum(rna_di_M_res$padj <= alpha & rna_di_M_res$log2FoldChange >= 0, na.rm = TRUE)
```

```{r}
#| label: tab-rna_di_de_genes

rna_di_res_df <- data.frame("Female RNA DI" = c(Down_F, NotSig_F, Up_F),
                           "Male RNA DI" = c(Down_M, NotSig_M, Up_M))

rownames(rna_di_res_df) <- c("Down", "NotSig", "Up")

rna_di_res_df |> gt(rownames_to_stub = TRUE)
```
Volcano plots
```{r}
volcano_plot(rna_di_F_res, "Female RNA Dimorphism index") +
volcano_plot(rna_di_M_res, "Male RNA Dimorphism index")
```
(Interpretation of the log2 FC:  If the variable of interest is continuous-valued, then the reported log2 fold change is per unit of change of that variable.)

```{r}
# Up- and down-regulated genes according to dimorphism index in females
set_up_F <- rna_di_F_res |> as.data.frame() |> filter(padj < alpha & log2FoldChange > 0) |> rownames()
set_down_F <- rna_di_F_res |> as.data.frame() |> filter(padj < alpha & log2FoldChange < 0) |> rownames()

set_di_F <- c(set_up_F, set_down_F)

# Up- and down-regulated genes according to dimorphism index in males
set_up_M <- rna_di_M_res |> as.data.frame() |> filter(padj < alpha & log2FoldChange > 0) |> rownames()
set_down_M <- rna_di_M_res |> as.data.frame() |> filter(padj < alpha & log2FoldChange < 0) |> rownames()

set_di_M <- c(set_up_M, set_down_M)
```
```{r}
venn_cols <- hue_pal()(4)

venn.plot <- venn.diagram(
  x = list(up_F = set_up_F, down_F = set_down_F, up_M = set_up_M, down_M = set_down_M),
  category.names = c("Females Up", "Females Down", "Males Up", "Males Down"),
  filename = NULL,
  fill = venn_cols,
  col = venn_cols,
  fontfamily = "sans",
  # Set names
  cat.cex = 1,
  cat.fontface = "bold",
  cat.default.pos = "outer",
  cat.fontfamily = "sans",
  cat.col = venn_cols,
  height = 480,
  width = 480,
  scaled = TRUE
)

# Plot the Venn diagram
grid.newpage()
grid.draw(venn.plot)
```


### Genes associated with sex

```{r}
sex_res <- results(filtered_counts_ds, contrast = c("SEX", "M", "F")) # log2 Fold-Change = Male / Female

NotSig_SEX <- sum(sex_res$padj >= alpha, na.rm = TRUE)
Dow_SEX <- sum(sex_res$padj <= alpha & sex_res$log2FoldChange < 0, na.rm = TRUE)
Up_SEX <- sum(sex_res$padj <= alpha & sex_res$log2FoldChange > 0, na.rm = TRUE)

# Showing the results
sex_res_df <- data.frame("SEX_M_vs_F" = c(Dow_SEX, NotSig_SEX, Up_SEX))
rownames(sex_res_df) <- c("Down", "NotSig", "Up")
sex_res_df |> gt(rownames_to_stub = TRUE)
```
```{r}
volcano_plot(sex_res, "Differentially expressed genes according to sex")
```


### Genes associated with age

```{r}
age_res <- results(filtered_counts_ds, name = "AGE_CONTINUOUS", alpha = alpha)

NotSig_AGE <- sum(age_res$padj >= alpha, na.rm = TRUE)
Dow_AGE <- sum(age_res$padj <= alpha & age_res$log2FoldChange < 0, na.rm = TRUE)
Up_AGE <- sum(age_res$padj <= alpha & age_res$log2FoldChange > 0, na.rm = TRUE)

# Showing the results
age_res_df <- data.frame("AGE_CONTINUOUS" = c(Dow_AGE, NotSig_AGE, Up_AGE))
rownames(age_res_df) <- c("Down", "NotSig", "Up")
age_res_df |> gt(rownames_to_stub = TRUE)
```
```{r}
volcano_plot(age_res, "Differentially expressed genes according to age (continuous)")
```
Heatmap of the VST transformed counts of the 30 most significant genes (lowest adjusted p-values), with samples annotated with sex, age, as color annotation.

```{r}
top30_age_genes <- age_res |> as.data.frame() |> 
  slice_min(padj, n = 30) |> 
  rownames()

female_samples <- covariates |> 
  filter(SEX == "F") |> 
  select(SUBJID) |> 
  unlist(use.names = FALSE)

male_samples <- covariates |> 
  filter(SEX == "M") |> 
  select(SUBJID) |> 
  unlist(use.names = FALSE)

# All sexes confounded
assay(vst_counts)[top30_age_genes,] |> 
  pheatmap(scale = "row",
           cluster_cols = TRUE,
           annotation_col = covariates |> column_to_rownames(var ="SUBJID") |>  select("AGE_DECADE", "SEX"))

# Female heatmap
assay(vst_counts)[top30_age_genes, female_samples] |>
  pheatmap(scale = "row",
           cluster_cols = TRUE,
           annotation_col = covariates |> column_to_rownames(var ="SUBJID") |>  select("AGE_DECADE"))


# Male heatmap
assay(vst_counts)[top30_age_genes, male_samples] |>
  pheatmap(scale = "row",
           cluster_cols = TRUE,
           show_colnames = FALSE,
           annotation_col = covariates |> column_to_rownames(var ="SUBJID") |>  select("AGE_DECADE"))


```


### Genes associated with the hardy scale

Hypothèse principale testée en ANOVA 1: tester si toutes les populations sont de même moyenne (H0: mu1 = mu2 = mu3 = ... = mu, H1: deux moyennes au moins sont différentes) --> We want to do something similar with the HARDY_SCALE variable. With the other covariates (SEX, RNA_DI and AGE_CONTINUOUS), we used the Wald significance test. The Wald test tests "for significance of coefficients in a Negative Binomial GLM" (H0: beta = 0). However, the Hardy scale has 5 different levels, and testing if genes are differentially expressed between each level (e.g. level 0 vs level 1, level 0 vs level 2, etc.), would require to make 10 (5*(5-1)/2) contrasts. This is called multiple testing and it would thus require corrections of the p-value to control the type 1 error rate.

But, with our biological question, which is to identify genes associated with sexual dimorphism in adipose tissue, knowing which genes are associated with each hardy scale level is not biologically interesting. Therefore, we will use the likelihood ratio test which is "an alternative to pair-wise comparisons" and is used "to analyze all levels of a factor at once" (like in ANOVA). (source: https://hbctraining.github.io/DGE_workshop/lessons/08_DGE_LRT.html)

```{r}
dds_lrt <- DESeq(filtered_counts_ds, test = "LRT", reduced = ~ AGE_CONTINUOUS + SEX + SEX:RNA_DI)
res_lrt <- results(dds_lrt)

```
```{r}
volcano_plot(res_lrt, "Hardy scale")
```

```{r}
sig_hardy_genes <- res_lrt |> 
  as.data.frame() |> 
  slice_min(order_by = padj, n = 9) |> 
  rownames()

length(sig_hardy_genes)
```

```{r}
fcounts_long <- filtered_counts |> rownames_to_column("gene_id") |> 
  pivot_longer(cols = - gene_id, names_to = "SUBJID", values_to = "counts")

fcounts_long <- left_join(fcounts_long, covariates |> select(SUBJID, HARDY_SCALE), by = "SUBJID")

fcounts_long |> 
  filter(gene_id %in% sig_hardy_genes) |> 
  ggplot(aes(x = HARDY_SCALE, y = counts, fill = HARDY_SCALE)) +
  geom_boxplot(outlier.size = 0.8, outlier.alpha = 0.6) +
  facet_wrap(~ gene_id, scales = "free_y", ncol = 3) +
  labs(x = "Hardy Scale",
       y = "Raw Counts") +
  ggtitle("Top 9 genes with lowest adjusted p-value for the \n 
          likelihood ratio test on HARDY_SCALE covariate")
  

  
```





Question about statistical power: see my project P3 from traitement statistique des données -omiques.


--> Résumé: table of (FDR) adjusted p-values or heatmap (gene vs. factor + color = adjusted p-value)


# Q3:
1. GSEA using fgsea package (see my main project traitement statistique des données -omiques) using the reactome gmt file? Or just find genes associated with receptors?

Importing the REACTOME GMT file
```{r}
gmt.file <- "resources/c2.cp.reactome.v2024.1.Hs.symbols.gmt"
reactome <- gmtPathways(gmt.file)
```

## ((Gene Ontology Analysis)) (to identify hormone receptors associated with the dimorphism indices and sex)

```{r}
all_genes <- rownames(rna_di_F_res)

sig_di_f_genes <- rna_di_F_res |>  as.data.frame() |> 
  filter(padj <= alpha) |> 
  rownames()

sig_di_m_genes <- rna_di_M_res |>  as.data.frame() |> 
  filter(padj <= alpha) |> 
  rownames()

sig_sex_genes <- sex_res |>  as.data.frame() |> 
  filter(padj <= alpha) |> 
  rownames()

```


```{r}
#hormone_pathways <- reactome[str_detect(names(reactome),"HORMONE")]
receptor_pathways <- reactome[str_detect(names(reactome),"RECEPTOR")]

sig_receptor_genes <- data.frame(
  pathway = character(),
  f_di = numeric(),
  m_di = numeric(),
  sex = numeric(),
  stringsAsFactors = FALSE
)

for (i in 1:length(receptor_pathways)){
  found_genes_f_di <- sum(sig_di_f_genes %in% receptor_pathways[[i]])
  found_genes_m_di <- sum(sig_di_m_genes %in% receptor_pathways[[i]])
  found_genes_sex <- sum(sig_sex_genes %in% receptor_pathways[[i]])
  
  sig_receptor_genes <- sig_receptor_genes |> add_row(pathway = names(receptor_pathways)[i],
                                              f_di = found_genes_f_di,
                                              m_di = found_genes_m_di,
                                              sex = found_genes_sex)
}
```


```{r}
# Function to process the strings
process_strings <- function(x) {
  x <- gsub("_", " ", x)          # Replace underscores with spaces
  x <- tolower(x)                 # Convert to lower case
  x <- sub("^\\S+\\s+", "", x)    # Remove the first word
  return(x)
}
```

```{r}
sig_receptor_genes |> 
  mutate(pathway = process_strings(pathway)) |> 
  filter(f_di != 0 & m_di != 0 & sex != 0) |>
  rowwise() |>
  mutate(total_sig = sum(c_across(c(f_di, m_di, sex)))) |>
  ungroup() |>
  mutate(pathway = fct_reorder(pathway, total_sig, .desc = FALSE)) |>
  pivot_longer(cols = c(f_di, m_di, sex),
               names_to = "covariate",
               values_to = "n_sig_genes") |>
  ggplot(aes(x = covariate, y = pathway, fill = n_sig_genes)) +
  geom_tile() +
  viridis::scale_fill_viridis(option = "turbo")
```

Do it manually instead????


### Female Dimorphism Index

### Male Dimorphism Index

### Sex


## Gene Set Enrichment Analysis (to identify pathways associated with the dimorphism indices and sex)


```{r}
# Female dimorphism index - genes ranked by log2 FC
ranked_genes_di_F <- rna_di_F_res$log2FoldChange
names(ranked_genes_di_F) <- rownames(rna_di_F_res)
ranked_genes_di_F <- sort(ranked_genes_di_F, decreasing = TRUE)

# Male dimorphism index
ranked_genes_di_M <- rna_di_M_res$log2FoldChange
names(ranked_genes_di_M) <- rownames(rna_di_M_res)
ranked_genes_di_M <- sort(ranked_genes_di_M, decreasing = TRUE)

# Sex
ranked_genes_sex <- sex_res$log2FoldChange
names(ranked_genes_sex) <- rownames(sex_res)
ranked_genes_sex <- sort(ranked_genes_sex, decreasing = TRUE)
```

### Female dimorphism index

```{r}
fgsea_results_di_F <- fgsea(
    pathways = reactome,
    stats = ranked_genes_di_F,
    minSize = 15,
    maxSize = Inf
)

gsea_res_plots(fgsea_results_di_F)
```


```{r}
#plotEnrichment(reactome[[head(fgsea_results_di_F[order(padj), ], 1)$pathway]],
#               ranked_genes_di_F) + 
#  labs(title = head(fgsea_results_di_F[order(padj), ], 1)$pathway)
```

### Male dimorphism index

```{r}
fgsea_results_di_M <- fgsea(
    pathways = reactome,
    stats = ranked_genes_di_M,
    minSize = 15,
    maxSize = Inf
)

topPathwaysUp_M <- fgsea_results_di_M |> filter(ES > 0 & padj < alpha)
topPathwaysDown_M <- fgsea_results_di_M |> filter(ES < 0 & padj < alpha)

# Plots of the results
plot_up_di_M <- topPathwaysUp_M |> 
  mutate(pathway = pathway |> process_strings() |>  str_wrap(width = 40) ) |> 
  ggplot(aes(reorder(pathway, NES), NES)) +
    geom_col(fill = hue_pal()(2)[2]) +
    coord_flip() +
    labs(x="Pathway", y="Normalized Enrichment Score",
         title="Top upregulated Reactome pathways") 

plot_down_di_M <- topPathwaysDown_M |> 
  mutate(pathway = pathway |> process_strings() |>  str_wrap(width = 40) ) |> 
  ggplot(aes(reorder(pathway, NES), NES)) +
    geom_col(fill = hue_pal()(2)[1]) +
    coord_flip() +
    labs(x="Pathway", y="Normalized Enrichment Score",
         title="Top upregulated Reactome pathways") 

plot_up_di_M + plot_down_di_M
```


```{r}

fgsea_results_di_M |> gsea_res_plots()
```

# Analyses supplémentaires
idées:
- Clustering hiérarchique ou k-means avec k = 2, pour voir si bonne séparation homme-femmes
- Machine learning: régression logistique régularisée pour voir si àpd expression gènes, on peut identifier hommes et femmes + quels gènes sont importants.

# Annex: session information {.unnumbered}

```{r}
sessionInfo()
```












